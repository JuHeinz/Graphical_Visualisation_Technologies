<!DOCTYPE html>
<html lang="de" data-bs-theme="dark">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width">
        <title>EA 8 | Graphical Visualisation Technologies</title>

        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet"
            integrity="sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB" crossorigin="anonymous">

        <link rel="stylesheet" href="../styles.css">
        <link rel="stylesheet" href="./ea8.css">
        <script src="../ext/gl-matrix.js"></script>
        <script src="../models/vertexData_torus.js"></script>
        <script src="../models/vertexData_plane.js"></script>
        <script src="../models/vertexData_sphere.js"></script>
        <script src="../models/vertexData_icosahedron.js"></script>

        <script src="./ea8.js"></script>

        <!--VERTEX SHADER-->
        <script type="x-shader/x-vertex" id="vertexshader">
        attribute vec3 aPosition; //// Vertex-Position (x,y,z - Koordinaten).
        attribute vec3 aNormal; //Normale Die Normalen für das Vertex. Hier unabhängig von der Model-View Marix. Nur auf die Geometrie der Vertices bezogen.

        uniform mat4 uPMatrix; // Camera Projection: Wurde in JS berechnet aus dem Projection-Type sowie Werten der Near- und Far-Clipping Planes.	
        uniform mat4 uMVMatrix; // Model-View Matrix: Wurde in JS berechnet aus Model-Matrix (Translation, Rotation, Scale) und View Matrix (Atribute der Camera, u.a. eye).
        uniform mat3 uNMatrix; // Normals in Relation zur Model-ViewMatrix (also z.B. zur Kamera-Position). Wurd ein JS von gl-Matrix aus der MV-Matrix berechnet.         

        //uniform vec4 uColor; //Einheitliche Farbe für jedes Vertex. Wurde in JS als z.B. [1,0,0,1] (rot) festgelegt.
        varying vec4 vColor; // Wird in Vertex Shader berechnet und an Fragment Shader weitergegeben


        /* == LIGHTS == */
        uniform vec3 ambientLight; // Ambient light.

        const int MAX_LIGHT_SOURCES = 8;
        struct LightSource { //Define struct for point lights
            bool isOn;
            vec3 position;
            vec3 color;
        };

        uniform LightSource light[MAX_LIGHT_SOURCES]; //Array of Type LightSource

        /* == MATERIAL ==*/
        struct PhongMaterial {
            vec3 ka; //Ambienter Reflektivitäts-Koeffizient als RGB
            vec3 kd; //Diffuser Reflektivitäts-Koeffizient als RGB
            vec3 ks; //Spekularer Reflektivitäts-Koeffizient als RGB
            float ke; //Shininess 
        };

        uniform PhongMaterial material;

        /* PHONG CALCULATION: 
            Berechnung der Diffusen und Spekularen Reflexions eines Punkts nach der Formel fürs Phong-Shading.
            Für eine Lichtquelle, ohne Ambient Light.
            p = Point-Vector: x,y,z Position des Vertex (in Eye-Koordinaten)
            n = Normale der Oberfläche 
            v = View Vektor / Eye-Koordinaten / Richtung, aus dem die Kamera den Punkt sieht.
            l = eine LightSource mit position und color.  
        */
        vec3 phong(vec3 p, vec3 n, vec3 v, LightSource l) {
            
            vec3 L = l.color; //Farbe der Lichtquelle

            // Richtung der Lichtquelle (s) berechnen: Position der Lichtquelle - Position des Punktes.  
            vec3 s = normalize(l.position - p); //Richtung von Quelle zum Punkt (normiert)

            // Richtung des reflektierten Lichts (Reflexionsvektor r) berechnen, mit der reflect() Funktion von GLSL.
            // Vorzeichen von s umdrehen, damit r von dem Oberflächenpunkt p weg zeigt. 
            vec3 r = reflect(-s, n); 
            
            

            // BERECHNUNG DIFFUSE REFLEKTION 
            float sn = max( dot(s,n), 0.0); // Richtungsvektor des Lichts und Normale skalar multiplizieren.         
            // max() -> Nur positive Werte werden berücksichtigt, ansonsten werden Backfaces beleuchtet. 
            /* sn = ein Wert zwischen 0 und 1. Wenn man diesen cos() nimmt, erhält man den Winkel zischen Richtungsvektor und Normalvektor.
                1 = Vektoren sind parallel
                0 = Vektoren stehen senkrecht aufeinander.
            */
            //Verrechnung mit Farbe des Lichtes und Materialeigenschaften.    
            vec3 diffuse = material.kd * L * sn;
			

            // BERECHNUNG SPEKULARE REFLEKTION
            float rv = max( dot(r,v), 0.0); // Lichtrichtung und Kamerarichtung skalar multiplizieren.
              /* rv = ein Wert zwischen 0 und 1. Wenn man diesen cos() nimmt, erhält man den Winkel zischen Lichtrichtung und Kamerarichtung.
                1 = Vektoren sind parallel
                0 = Vektoren stehen senkrecht aufeinander.
            */
            //Verrechnung mit Farbe des Lichtes, Materialeingenschaften und Shininess.    
            vec3 specular = material.ks * L * pow(rv, material.ke);

            return diffuse + specular;			
        }

        /* PHONG-Calculation: Errechnet Beleuchtung der Oberfläche an der Position p. Mit mehreren Lichtquellen und Ambient Light. 
            p = Vektor zum Oberflächenpunkt
            n = Oberflächennormale
            v = View Vektor
        */
        vec3 phong(vec3 p, vec3 n, vec3 v) {
            // Ambient Light aus Material und allgemeinem Ambient Light berechnen. 
            vec3 result = material.ka * ambientLight;

            // Add light from all light sources.
            for(int j = 0; j < MAX_LIGHT_SOURCES; j++) {
                if(light[j].isOn) { //Wenn das licht an, füge es zur Gesamt-Beleuchtung hinzu. 
                    result += phong(p, n, v, light[j]);
                }
            }
            return result; //ein rgb Vektor.
        }


        void main() {
            //Vertex Positionen zu Eye-Koordinaten mit der ModelView Matrix transformieren.
            vec4 tPosition = uMVMatrix * vec4(aPosition, 1.0);

            // gl_Position anhand der Projection-Matrix und und den eye-Koordinaten berechnen. Haupt-Aufgabe jedes Vertex-Shaders.
            gl_Position = uPMatrix * tPosition;

            // Bestimmen der korrekt gedrehte Normale tNormal aus aNormal mittels der Normal-Matrix uNMatrix.
            // So stimmen die Normals auch, wenn man das Modell dreht.
            vec3 tNormal = normalize(uNMatrix * aNormal);// normalize = Vektor länge 1 geben.

            /* BESTIMMUNG DER FARBE FÜR DEN FRAGMENT SHADER */
            vec3 viewVector = normalize(-tPosition.xyz); //Eye-Koordinaten normalisieren und vierte Dimension fallen lassen. 

            //Farbe berechnen
            vColor = vec4(phong(tPosition.xyz, tNormal, viewVector), 1.0);

        }

		</script>

        <!--FRAGMENT SHADER-->
        <script type="x-shader/x-fragment" id="fragmentshader">
			precision mediump float;
			varying vec4 vColor;

			void main() {
                gl_FragColor = vColor;
			}
		</script>

    </head>

    <body onload="app.start()">

        <header>
            <nav class="navbar navbar-expand-lg bg-body-tertiary" id="global-nav">
                <div class="container-fluid">
                    <a class="navbar-brand" href="#">Graphical Visualisation Technologies</a>

                    <div class="navbar-nav">
                        <a class="nav-link " href="../index.html">Aufgabenübersicht</a>
                    </div>

                </div>
            </nav>

            <div class="title-section">
                <h1 class="display-5">Einsendeaufgabe 8</h1>
                <p class="lead">
                    Lichter auf einer Kreisbahn mit Toon Shading
                </p>
            </div>

        </header>

        <main>
            <canvas id="canvas"></canvas>

            <div class="controls">
                <div>
                    <h2 class="h3 fw-light">Kamera Interaktion</h2>

                    <ul class="list-group-flush">
                        <li class="list-group-item">
                            <span class="badge text-bg-dark"><code>W,S</code></span>
                            auf Y-Ebene bewegen
                        </li>
                        <li class="list-group-item">
                            <span class="badge text-bg-dark"><code>A,D</code></span>
                            auf X-Ebene bewegen
                        </li>
                        <li class="list-group-item"> <span class="badge text-bg-dark"><code>Pfeiltasten</code></span>
                            Kamera kreisen </li>
                        <li class="list-group-item">
                            <span class="badge text-bg-dark"><code>(Shift) + n</code></span> Kamera Distanz ändern
                        </li>
                        <li class="list-group-item"><span class="badge text-bg-dark">
                                <code>p</code> , <code>o</code> , <code>f</code></span> Projektion
                            umschalten. </li>
                        <li class="list-group-item"> <span class="badge text-bg-dark"><code>r</code></span> Reset</li>
                    </ul>

                </div>

                <div>
                    <h2 class="h3 fw-light">Benutzerhinweis</h2>

                    <p>Nach Ändern der ViewPort-Größe (z.B. durch Öffnen der Dev-Tools oder Resizing des Fensters)
                        muss die Seite neu geladen werden, damit die Canvas scharf erscheint.</p>
                </div>

                <div>
                    <h2 class="h3 fw-light">Dokumentation</h2>

                    <p>Die Vertex-Daten für das Icosahedron stammen aus dem Tutorial für Recursive Spheres von <a
                            href="http://blog.andreaskahler.com/2009/06/creating-icosphere-mesh-in-code.html">Andreas
                            Kahler</a></p>
                </div>
            </div>

        </main>

        <footer>
            <p class="text-body-secondary">Julia Heinzelmann</p>
            <p class="text-body-secondary">Berliner Hochschule für Technik </p>
            <p class="text-body-secondary"> <a
                    href="https://github.com/JuHeinz/Graphical_Visualisation_Technologies">Gitub Repository</a></p>
        </footer>

    </body>

</html>