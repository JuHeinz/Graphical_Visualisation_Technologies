<!DOCTYPE html>
<html>

  <head>
    <meta charset="UTF-8" />
    <title>SVG to WebGL Vertex Converter</title>
    <style>
      body {
        font-family: sans-serif;
        margin: 20px;
        background: #222;
        color: #eee;
      }

      canvas {
        width: 400px;
        height: 400px;
        background: #000;
        display: block;
        margin-top: 20px;
      }

      textarea {
        width: 100%;
        height: 100px;
      }

      button {
        padding: 10px;
        margin-top: 10px;
      }
    </style>
  </head>

  <body>
    <h2>SVG to WebGL Converter</h2>
    <textarea id="svgInput" placeholder="Paste inline SVG here..."></textarea>
    <button onclick="convertSVG()">Convert & Render</button>

    <h3>Generated Vertices:</h3>
    <pre id="output"></pre>

    <canvas id="glcanvas" width="400" height="400"></canvas>

    <script>
      function parsePoints(pointsStr) {
        return pointsStr.trim().split(/\s+/).flatMap(p => p.split(',').map(Number));
      }

      function normalizeVertices(vertices, width, height) {
        const out = [];
        for (let i = 0; i < vertices.length; i += 2) {
          const x = (vertices[i] / width) * 2 - 1;
          const y = 1 - (vertices[i + 1] / height) * 2;
          out.push(x, y);
        }
        return out;
      }

      function triangulateRectangle() {
        return [0, 1, 2, 0, 2, 3];
      }

      function convertSVG() {
        const parser = new DOMParser();
        const doc = parser.parseFromString(document.getElementById("svgInput").value, "image/svg+xml");
        const poly = doc.querySelector('polygon');
        if (!poly) {
          alert('Only <polygon> supported.');
          return;
        }

        const svg = doc.querySelector('svg');
        const width = parseFloat(svg.getAttribute('width'));
        const height = parseFloat(svg.getAttribute('height'));

        const vertices = parsePoints(poly.getAttribute('points'));
        const normalized = normalizeVertices(vertices, width, height);

        document.getElementById('output').textContent = JSON.stringify(normalized);
        renderWebGL(normalized);
      }

      function renderWebGL(vertices) {
        const canvas = document.getElementById('glcanvas');
        const gl = canvas.getContext('webgl');

        const vsSrc = `attribute vec2 aPos; void main(){ gl_Position = vec4(aPos, 0.0, 1.0); }`;
        const fsSrc = `void main(){ gl_FragColor = vec4(0.0, 1.0, 0.0, 1.0); }`;

        const vShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vShader, vsSrc);
        gl.compileShader(vShader);

        const fShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fShader, fsSrc);
        gl.compileShader(fShader);

        const program = gl.createProgram();
        gl.attachShader(program, vShader);
        gl.attachShader(program, fShader);
        gl.linkProgram(program);
        gl.useProgram(program);

        const vbo = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

        const loc = gl.getAttribLocation(program, 'aPos');
        gl.enableVertexAttribArray(loc);
        gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);

        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);
        const indexCount = vertices.length / 2;
        const indices = new Uint16Array(Array.from({ length: indexCount }, (_, i) => i));

        const ibo = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

        gl.drawElements(gl.TRIANGLE_FAN, indexCount, gl.UNSIGNED_SHORT, 0);
      }
    </script>
  </body>

</html>